{"version":"0.2.0","body":"// ============================= definitions: Change these if excel workbook changes =============================\nlet COURSE_TRANSPOSE = \"Courses transpose\"; // name of the course transpose sheet showing who covers what course\nlet SCHEDULE = \"Automate Schedule\"; // name of the schedule sheet showing when learing assistants will be in\nlet SBCSheetName = \"Schedule By Courses\"\nlet COURSE_ROW = 0; // which row in COURSE_TRANSPOSE does the course names live in?\nlet COURSE_COL_START = 1; // which column in COURSE_TRANSPOSE does the course names start in? \nlet COURSE_NAME_START = 1; // which row does the LA names start in COURSE_TRANSPOSE?\nlet COURSE_NAME_COL = 0; // which column are the names in COURSE_TRANSPOSE?\nlet SCHEDULE_NAME_START = 4; // which row do the names start in SHCUDULE?\nlet SCHEDULE_NAME_COL = 0;  // which column are the names in SCHEDULE?\nlet COURSE_FILL_COLOR = \"d9d9d9\";\nlet SUMMARY_FILL_COLOR = \"ffe699\";\n\nfunction main(workbook: ExcelScript.Workbook) {\n  let errors : string[] = [];\n  let fatal = false; \n  \n  // get the course tranpose sheet and the learning assistant schedule sheet \n  let schedSheet = workbook.getWorksheet(SCHEDULE);\n  let tranSheet = workbook.getWorksheet(COURSE_TRANSPOSE);\n\n  // ensure both sheets exist in the work book, report errors if they do not \n  if(schedSheet == undefined){\n    errors.push(\"Crtical error: The worksheet '\" + SCHEDULE + \"' was not found in this workbook. Please check tab name and try again\");\n    fatal = true;\n  }\n  if(tranSheet == undefined){\n    errors.push(\"Crtical error: The worksheet '\" + COURSE_TRANSPOSE + \"' was not found in this workbook. Please check tab name and try again\");\n    fatal = true; \n  }\n\n\n  // create new SBC sheet in current workbook\n  let sbc = createSBC(workbook, SBCSheetName);\n\n  if(!fatal){\n    // convert raw sheet data to strings \n    let schedule = worksheetToStrArry(schedSheet);\n    let courses = worksheetToStrArry(tranSheet);\n    let scNames = getStrsFromCol(schedule, SCHEDULE_NAME_START, SCHEDULE_NAME_COL);\n    let coNames = getStrsFromCol(courses, COURSE_NAME_START, COURSE_NAME_COL);\n    let shifts = slice2d(schedule, SCHEDULE_NAME_START, SCHEDULE_NAME_COL + 1);\n\n    // make sure names are the same across schedule and transpose sheets \n    errors = checkForErrors(courses, schedule, coNames,scNames,tranSheet,schedSheet);\n\n    // create a list of learning assistant objects \n    let assistants = LCScheduleTools.buildLAList(courses, schedule);\n\n    // create a list of course objects from course names and assistant objects \n    let courseNames = getStrsFromRow(courses, COURSE_COL_START, COURSE_ROW);\n    let courseList = LCScheduleTools.buildCourseList(courseNames, assistants);\n\n    // write data to new SBC sheet\n    writeSBC(sbc, courseList, errors, true);\n  } else {\n    writeErrors(errors, sbc, 0, 7);\n  }\n}\n\nenum Day {\n  Monday, Tuesday, Wednesday, Thursday, Friday, Saturday,\n}\n\n// ======================== Class Time ====================================================\n// Stores the time of day in minutes and provides some simple methods for working between\n// string and number representations \nclass Time {\n  // attributes \n  private value: number;\n\n  // ----------- constructor --------------\n  constructor(newVal: number) {\n    // value must coorispond to a 24 hour clock. value of -1 or over 1439 is invalid \n    if (!this.setTime(newVal)) {\n      this.value = -1;\n    }\n  }\n\n  // ----------- mutators -----------------\n  setTime(newVal: number): boolean { // only change value if valid on a 24 hour clock\n    if (newVal >= 0 && newVal < 1440) {\n      this.value = newVal;\n      return true;\n    }\n    return false;\n  }\n  setFrom24String(newTime: string): boolean { // sets from a string in 24 hour format. 23:00 or 23\n    // conversion aray\n    let convertedTime: string[];\n    let time: number;\n\n    // separate minutes and hours\n    if (newTime.includes(\":\")) {\n      convertedTime = newTime.split(\":\");\n    } else {\n      convertedTime = [newTime, \"00\"];\n    }\n    let hours = parseInt(convertedTime[0]);\n    let minutes = parseInt(convertedTime[1]);\n\n    // check to make sure both parts of the new time are valid numbers\n    if (hours != Number.NaN && minutes != Number.NaN) {\n      time = hours * 60 + minutes;\n    } else {\n      return false\n    }\n\n    // attempt to set the time and return what set time provides\n    return this.setTime(time);\n  }\n\n  setFrom12String(newTime: string, isPM: boolean): boolean { // sets from a string in a 12 hour format \n    // conversion aray\n    let convertedTime: string[];\n    let time: number;\n\n    // separate minutes and hours\n    if (newTime.includes(\":\")) {\n      convertedTime = newTime.split(\":\");\n    } else {\n      convertedTime = [newTime, \"00\"];\n    }\n    let hours = parseInt(convertedTime[0]);\n    if (isPM && hours < 12) {\n      hours += 12;\n    } else if (!isPM && hours == 12) {\n      hours = 0;\n    }\n    let minutes = parseInt(convertedTime[1]);\n\n    // check to make sure both parts of the new time are valid numbers\n    if (hours != Number.NaN && minutes != Number.NaN) {\n      time = hours * 60 + minutes;\n    } else {\n      return false\n    }\n\n    // attempt to set the time and return what set time provides\n    return this.setTime(time);\n  }\n\n\n  // ----------- accessors ---------------------\n  getTime() {\n    return this.value;\n  }\n\n  get24String(): string {\n    let returnTime = Math.floor(this.value / 60).toString();\n    returnTime += \":\";\n    if (this.value % 60 < 10) {\n      returnTime += \"0\";\n    }\n\n    return returnTime + this.value % 60;\n  }\n\n  get12String(showMaridian : boolean): string {\n    // convert minute value to 12 hour clock\n    let hour = Math.floor(this.value / 60);\n    let minute = (this.value % 60).toString();\n    let amOrPm = \"\";\n\n\n    // determine if am or pm and adjust \n    if (showMaridian){\n      amOrPm = \"am\";\n    }\n    if (hour > 12) {\n      hour -= 12;\n      if(showMaridian){\n        amOrPm = \"pm\";\n      }\n    } else if (hour == 12 && showMaridian) {\n      amOrPm = \"pm\";\n    }\n\n    // determine if midnight \n    if (hour == 0) {\n      hour = 12;\n    }\n\n    // determine if minute needs a padding 0 \n    if (minute.length < 2) {\n      minute = \"0\" + minute;\n    }\n\n    // assemble string and return \n    return hour + \":\" + minute + amOrPm;\n  }\n\n  // ------------- utility -------------------------------\n  isValid() { // checks to ensure the current time is on a 24 hour clock\n    if (this.value >= 0 && this.value < 1440) {\n      return true;\n    }\n    return false;\n  }\n\n  static isTime(testMe : string){\n    if(testMe == undefined || testMe == null){\n      return false;\n    }\n    return this.is12(testMe) || this.is24(testMe);\n  }\n\n  static is24(testMe : string){\n    if(testMe == undefined || testMe == null){\n      return false; \n    }\n    // create a time object to to test incoming number with\n    let time = new Time(0);\n    return time.setFrom12String(testMe, false);\n  }\n\n  static is12(testMe : string){\n    if (testMe == undefined || testMe == null) {\n      return false;\n    }\n    // create a time object to to test incoming number with\n    let time = new Time(0);\n    return time.setFrom24String(testMe);\n  }\n}\n\n// =================== class Shift ==============================================\n// represents a single contiguous shift using minute based representation of time of day\n// return strings where aplicable are in 12 hour format \nclass Shift {\n  // --------- Attributes ----------------------\n  private start: Time;\n  private end: Time;\n\n  // --------- constructor ---------------------\n  constructor(start: number, end: number) {\n    this.start = new Time(start);\n    this.end = new Time(end);\n  }\n\n  // -------- mutators -------------------------\n  setStart(start: Time): boolean { // sets start through new time object \n    if (start.isValid()) {\n      this.start = start;\n      return true;\n    }\n    return false;\n  }\n\n  setStartByNum(start: number): boolean { // sets start using minute based time of day\n    if (start >= 0 && start < 1440) {\n      return this.start.setTime(start);\n    }\n    return false;\n  }\n\n  setStartByStr(start : string): boolean {// sets start using a 12 hour string representation of a time: IE 12:25pm \n    let isPm = start.toLowerCase().includes(\"pm\");\n\n    // remove the AM/PM descriptor from the passed in string \n    if (start.toLowerCase().includes(\"pm\")) {\n      start = start.substring(0, start.toLowerCase().indexOf(\"p\"));\n    }\n    if (start.toLowerCase().includes('am')) {\n      start = start.substring(0, start.toLowerCase().indexOf(\"a\"));\n    }\n    // attempt to set the start value and return the result \n    return this.start.setFrom12String(start, isPm);\n  }\n\n  setEnd(end: Time): boolean { // sets end through new time object \n    if (end.isValid()) {\n      this.end = end;\n      return true;\n    }\n    return false;\n  }\n\n  setEndByNum(end: number): boolean { // sets start using minute based time of day\n    if (end >= 0 && end < 1440) {\n      return this.end.setTime(end);\n    }\n    return false;\n  }\n\n  setEndByStr(end: string): boolean {// sets start using a 12 hour string representation of a time: IE 12:25pm \n    let isPm = end.toLowerCase().includes(\"pm\");\n\n    // remove the AM/PM descriptor from the passed in string \n    if (end.toLowerCase().includes(\"pm\")) {\n      end = end.substring(0, end.toLowerCase().indexOf(\"p\"));\n    }\n    if (end.toLowerCase().includes('am')) {\n      end = end.substring(0, end.toLowerCase().indexOf(\"a\"));\n    }\n\n    // attempt to set the start value and return the result \n    return this.end.setFrom12String(end, isPm);\n  }\n\n  // --------- accessors ----------------------\n  getStartNum(): number { // returns the minute based time of day for start attribute \n    return this.start.getTime();\n  }\n\n  getEndNum(): number { // returns the minute based time of day for the end attribute \n    return this.end.getTime();\n  }\n\n  getStart12(): string { // returns a string represntation of start time in 12 hour format \n    return this.start.get12String(false);\n  }\n\n  getEnd12(): string { // returns a string represntation of end time in 12 hour format\n    return this.end.get12String(false);\n  }\n  // --------- utility ------------------------\n  isValid(): boolean { // verifies that the schedule times fit within minutes in a day\n    return this.start.isValid() && this.end.isValid();\n  }\n\n  toString() {\n    return this.start.get12String(false) + \" - \" + this.end.get12String(false);\n  }\n\n  static isShift(testMe: string) {\n    if (testMe == undefined || testMe == null) {\n      return false;\n    }\n    if (!testMe.includes(\"-\")) {\n      return false;\n    }\n\n    let testTimes = testMe.split(\"-\");\n\n    if (testTimes.length < 2) {\n      return false;\n    }\n\n    for(let i = 0; i < testTimes.length; i++){\n      if(!Time.is12(testTimes[i])){\n        return false;\n      }\n    }\n    return true; \n  }\n}\n// ============================= start of class course ========================================\nclass Course {\n  // ---------------- attributes ---------------------------------\n  private name : string; // name of the course\n  private assistants : LearningAssistant[]; // list of LAs that cover the course \n\n  // ---------------- constructor --------------------------------\n  constructor (name : string, assistants : LearningAssistant[]){\n    // intialize attributes \n    this.name = name;\n    this.assistants = [];\n\n    // add learning assistants that have this course (by name) in their coverage list\n    for(let assistantNo = 0; assistantNo < assistants.length; assistantNo++){\n      if(assistants[assistantNo].coversCourse(this.name)){\n        this.addAssistant(assistants[assistantNo]);\n      }\n    } \n  }\n\n  // ---------------- accessors --------------------------------\n  getName() : string {\n    return this.name;\n  }\n\n  numAssistants() : number { \n    return this.assistants.length;\n  }\n\n  getAssistant(assistantNo : number) : LearningAssistant {\n    if(assistantNo >= 0 && assistantNo < this.assistants.length){\n      return this.assistants[assistantNo];\n    }\n    return null;\n  }\n\n  // ---------------- mutators --------------------------------\n  setName(name : string) : boolean {\n    if(name !== undefined && name !== null){\n      this.name = name;\n      return true;\n    }\n    return false;\n  }\n \n  addAssistant(newAssistant : LearningAssistant){\n    // validate the assistant \n    if(newAssistant === null || newAssistant === undefined){\n      return false;\n    }\n    // check to see if the assistant is already in the list\n    for(let i = 0; i < this.assistants.length; i++){\n      if(this.assistants[i].equals(newAssistant)){\n        return false; \n      }\n    }\n    // add the assistant to the list\n    this.assistants.push(newAssistant);\n    return true;\n  }\n\n  // ---------------- Utility --------------------------------\n  assistantScheduleList() : string[][] {\n    let returnLst : string[][] = [];\n    let weekly : string[];\n    for(let i = 0; i < this.assistants.length; i++){\n      returnLst.push([]);\n      returnLst[i].push(this.assistants[i].getName());\n      weekly = this.assistants[i].getWeekly();\n      for(var dayOfWeek in Day){\n        if(!isNaN(Number(dayOfWeek))){\n          returnLst[i].push(weekly[dayOfWeek]);\n        }\n      }\n    }\n    return returnLst;\n  }\n\n  coverageSummary() : string[] {\n    let summary : string [] = [];\n    let timer = new Time(0);\n    let buffer = \"\";\n    let onShift = false; \n    let hasFirstShift = false;\n\n    for(var dayOfWeek in Day){\n      if(!isNaN(Number(dayOfWeek))){\n        timer.setTime(0);\n        buffer = \"\";\n        onShift = false;\n        hasFirstShift = false;\n        for(let i = 0; i < 1440; i++){\n          if(onShift && !this.hasCoverage(Number(dayOfWeek), timer)){\n            onShift = false; \n            timer.setTime(timer.getTime() - 1);\n            buffer += timer.get12String(false);\n            timer.setTime(timer.getTime() + 1);\n            hasFirstShift = true; \n          }\n\n          if(!onShift && this.hasCoverage(Number(dayOfWeek), timer)){\n            onShift = true;\n            if(hasFirstShift){\n              buffer += \"; \";\n            }\n            buffer += timer.get12String(false) + \" - \";\n          }\n          if(timer.getTime() == 1440){\n            break;\n          }\n\n          timer.setTime(timer.getTime() + 1);\n        }\n        summary.push(buffer);\n      }\n    }\n    return summary;\n  }\n\n  hasCoverage(dayOfWeek : Day, time : Time) : boolean {\n    for(let assistantNo = 0; assistantNo < this.assistants.length; assistantNo++){\n      if(this.assistants[assistantNo].isAvailable(dayOfWeek, time)){\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n// ============================= start of class LearningAssistant =============================\nclass LearningAssistant {\n  // ---------------- attributes ---------------------------------\n  private name : string;// LAs full name last, first\n  private covers : string[] = []; // names of courses the LA covers\n  private schedule : Shift[][];\n\n  // ---------------- constructor --------------------------------\n  constructor(name : string, courses : string[], schedule : Shift[][]){\n    // intialize attributes \n    this.name =  name;\n    this.covers = []; \n    this.schedule = []; \n\n    // load the covers array with \n    for(let i = 0; i < courses.length; i++){\n      this.addCourse(courses[i]);\n    }\n\n    // load the schedule array\n    this.schedule = schedule;\n  }\n\n  // --------------------- accessors ----------------------------\n  getName(){\n      return this.name;\n  }\n\n  getDay(dayOfWeek : Day){ // returns the day schedule by full day name\n      if(this.schedule[dayOfWeek] !== undefined){\n          return this.schedule[dayOfWeek];\n      } \n      return null; \n  }\n\n  // ------------------- mutators ----------------------------\n  setName(name : string){\n      this.name = name;\n  }\n\n  // ------------------- utility ----------------------------\n  // allows adding to LA schedule using Day enumrator \n  addToSchedule(dayOfWeek : Day, newShift : Shift){\n    this.schedule[dayOfWeek].push(newShift);\n  }\n\n  // allows the use of strings to set a start and end of a new schedule element\n  addToSchedule12(dayOfWeek : Day, start : string, end : string) : boolean {\n    let tempShift = new Shift(0,0);\n    // check to make sure both times can be set\n    if(tempShift.setStartByStr(start) && tempShift.setEndByStr(end)){\n      // check to make sure the new shift contains valid times\n      if(tempShift.isValid()){\n        this.schedule[dayOfWeek].push(tempShift);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // determines if an LA covers a course \n  coversCourse(course : string){\n      for(let i = 0; i < this.covers.length; i++){\n          if(this.covers[i] === course){\n              return true;\n          }\n      }\n    return false;\n  }\n\n  // add a course to this LAs coverage list\n  addCourse(courseName : string) : void {\n      this.covers.push(courseName);\n  }\n\n  // get the LA schedule for a given day enum\n  getDayStr(dayOfWeek : Day) : string {\n    // variables \n    let temp = \"\";\n\n    // protect function from enum that is not a number\n    if( !isNaN(Number(dayOfWeek))){\n      // step through shifts, cat each into temp \n      for(let i = 0; i < this.schedule[Number(dayOfWeek)].length; i++){\n          if(i > 0){ // add delimter if more than one\n            temp += \" ; \";\n          }\n          temp += this.schedule[dayOfWeek][i].toString();\n      }\n      return temp;\n    }\n  }\n\n  // gets the weekly schedule in string[] form\n  getWeekly(){\n    // variables \n    let weeklySchedule : string [] = [];\n    let temp = \"\";\n\n    // step through days in the enum \n    for(var day in Day){\n      temp = \"\";\n\n    if(!isNaN(Number(day))){ // using enum as iterated index\n        // add shift to the current day\n        temp += this.getDayStr(Number(day));\n\n        // add accumulated shifts to return array\n        weeklySchedule.push(temp);\n      }\n    }\n    \n    return weeklySchedule;\n  }\n\n  // determines if a learning assistant is available at a given day and time\n  isAvailable(dayOfWeek : Day, time : Time) : boolean {\n\n    for(let i = 0; i < this.schedule[dayOfWeek].length; i++){\n      if(this.schedule[dayOfWeek][i].getStartNum() <= time.getTime() && time.getTime() <= this.schedule[dayOfWeek][i].getEndNum()){\n        return true; \n      }\n    }\n    return false; \n  }\n\n  // compares two learning assistants to see if they are the same\n  equals(compareMe : LearningAssistant) : boolean {\n    if(compareMe.getName() !== this.name){\n      return false; \n    }\n    for(let i = 0; i < this.covers.length; i++){\n      if(!compareMe.coversCourse(this.covers[i])){\n        return false; \n      }\n    }\n    return true; \n  }\n}\n\n// =================== functions for converting spreadsheet data to learning assistant =======================\nclass LCScheduleTools {\n  // creates data array for an schedule by courses sheet\n  static buildSBC(courses : Course[]){\n    let sbcArray : string[][] = [];\n    let scheduleList : string[][] = [];\n    let offset = 0; \n    for(let courseNo = 0; courseNo < courses.length; courseNo++){\n      //fill in header row\n      sbcArray.push([courses[courseNo].getName()]);\n      for(let dayName in Day){\n        if(isNaN(Number(dayName))){\n          sbcArray[courseNo + offset].push(dayName);\n        }\n      }\n\n      // fill in Learning Assistants \n      scheduleList = courses[courseNo].assistantScheduleList();\n      for(let assistantNo = 0; assistantNo < scheduleList.length; assistantNo++){\n        sbcArray.push(scheduleList[assistantNo]);\n        offset++;\n      }\n\n      // add coverage summary\n      if(courses[courseNo].numAssistants() > 0){ \n        sbcArray.push([\"Coverage\"].concat(courses[courseNo].coverageSummary()));\n        offset++;\n      }\n    }\n    return sbcArray;\n  }\n\n// builds a complete list of learning assistant objects from a string array containing courses \n  static buildLAList(courses: string[][], schedule: string[][]): LearningAssistant[] {\n    // instance variables \n    let assistants : LearningAssistant[] = [];\n    let nameBuff : string;\n    let scheduleBuff : string[];\n    let coverageBuff : string[]; \n    let courseNames : string[] = getStrsFromRow(courses, COURSE_COL_START, COURSE_ROW);\n    \n    for(let laNo = COURSE_NAME_START; laNo < courses.length; laNo++){\n      nameBuff = courses[laNo][COURSE_NAME_COL]; \n      scheduleBuff = this.getScheduleStrs(nameBuff, schedule);\n      if(scheduleBuff !== null){\n        coverageBuff = this.getCourseList(getStrsFromRow(courses, COURSE_COL_START, laNo),courseNames);\n        assistants.push(this.makeLA(nameBuff, coverageBuff, scheduleBuff));\n      }\n    }\n\n    // \n    return assistants;\n  }\n\n  static buildCourseList(courseNames : string[], assistants : LearningAssistant[]) : Course[] {\n    let courseList : Course[] = [];\n    for(let courseNo = 0; courseNo < courseNames.length; courseNo++){\n      courseList.push(new Course(courseNames[courseNo], assistants))\n    }\n    return courseList; \n  }\n\n  static getCourseList(markerList : string[], courseNames : string[]){\n    let rtrnList : string [] = [];\n    for(let courseNo = 0; courseNo < courseNames.length; courseNo++){\n      if(markerList[courseNo].toLowerCase().includes('x')){\n        rtrnList.push(courseNames[courseNo]);\n      }\n    }\n    return rtrnList;\n  }\n\n  static getScheduleStrs(name : string, schedule : string [][], nameCol : number = SCHEDULE_NAME_COL){\n    for(let i = 0; i < schedule.length; i++){\n      if(normalize(schedule[i][SCHEDULE_NAME_COL]).toLowerCase().includes(normalize(name).toLowerCase())){\n        return getStrsFromRow(schedule, SCHEDULE_NAME_COL, i);\n      }\n    }\n    return null;\n  }\n\n  static makeLA(name: string, courses: string[], schedule: string[]): LearningAssistant {\n    // instance variables\n    let shiftList : Shift[][] = [];\n    let scheduleSplitter : string[];\n    let shiftBuffer : Shift;\n\n    // iterate throuh days in the week \n    for(let i = SCHEDULE_NAME_COL + 1; i < schedule.length; i++){\n      shiftList.push([]);\n\n      // for LAs with multiple shifts in a day\n      if(schedule[i].includes(\";\")){\n        scheduleSplitter = schedule[i].split(\";\");\n      } else {\n        // for LAs with a single shift in a day\n        scheduleSplitter = [schedule[i]];\n      }\n\n      // convert all shift strings to shift objects \n      for(let j = 0; j < scheduleSplitter.length; j++){\n        shiftBuffer = this.shiftFromString(scheduleSplitter[j]);\n        if (shiftBuffer != null) {\n          shiftList[i-1].push(shiftBuffer);\n        }\n      }\n    }\n    return new LearningAssistant(name, courses, shiftList);\n  }\n\n  static shiftFromString(shiftStr : string) : Shift{\n    // check to make sure we can split this string appropriately\n    if(shiftStr === undefined){\n      return null;\n    }\n    if(!shiftStr.includes(\"-\")){ \n      return null;\n    }\n\n    let strArr = shiftStr.split(\"-\");\n    let startTime = new Time(0);\n    let endTime = new Time(0);\n\n    if (!startTime.setFrom12String(strArr[0], false) || !endTime.setFrom12String(strArr[1], false)){\n      return null;\n    }\n      \n    this.adaptTimeLC(startTime);\n    this.adaptTimeLC(endTime);\n\n    return new Shift(startTime.getTime(), endTime.getTime());\n  }\n\n  static adaptTimeLC(time : Time){\n    if(time.getTime() < 480){\n      time.setTime(time.getTime()+720);\n    }\n  }\n\n\n}\n// \n// loads a worksheet to a 2d string array of strings\nfunction worksheetToStrArry(sheet : ExcelScript.Worksheet) : string[][] {\n  // ensure the worksheet exists\n  let sheetData = sheet.getUsedRange().getValues();\n  let rtrnArry : string[][] = [];\n\n  for(let i = 0; i < sheetData.length; i++){\n    rtrnArry.push([]);\n    for(let j = 0; j < sheetData[i].length; j++){\n      rtrnArry[i].push(sheetData[i][j].toString());\n    }\n  }\n\n  return rtrnArry; \n}\n\n// returns target as a string with no spaces, all lower case \nfunction normalize(target: string): string {\n  let tgtArry = target.toLowerCase().split(\" \");\n  let result = \"\";\n  for (let i = 0; i < tgtArry.length; i++) {\n    result += tgtArry[i];\n  }\n  return result;\n}\n\n//gets all strings in specified array column from rowStart on \nfunction getStrsFromCol(list: string[][], rowStart: number, col: number) : string[] {\n  var strs: string[] = [];\n  for (let i = rowStart; i < list.length; i++) {\n    strs.push(list[i][col]);\n  }\n  return strs;\n}\n\nfunction slice2d(list : string[][], rowStart : number, colStart : number, rowEnd : number = undefined, colEnd : number = undefined) : string[][]{\n  // variables\n  let newList : string[][] = [];\n  if(rowEnd == undefined){rowEnd = list.length};\n \n  let rowCount = 0;   \n  for(let row = rowStart; row < rowEnd; row++){\n    newList.push([]);\n    if(colEnd == undefined){\n      for(let col = colStart; col < list[row].length; col++){\n        newList[rowCount].push(list[row][col]);\n      }\n    } else {\n      for (let col = colStart; col < colEnd; col++) {\n        newList[rowCount].push(list[row][col]);\n      }      \n    }\n  }\n  return newList;\n}\n// gets all strings in a specified array row from colStart on\nfunction getStrsFromRow(list : string[][], colStart : number, row : number) : string[]{\n  var strs : string[] = [];\n  for(let i = colStart; i < list[row].length; i++){\n    strs.push(list[row][i]);\n  }\n  return strs;\n}\n\nfunction writeSBC(worksheet : ExcelScript.Worksheet, courses : Course[], errors : string[], printable : boolean = false){\n  // create a new worksheet. Delete the old one if applicable \n  if (printable) {\n    courses = makePrintable(courses);\n  }\n  let sheetData = LCScheduleTools.buildSBC(courses);\n  let currentRow = 0;\n\n  currentRow += writeErrors(errors, worksheet); \n  currentRow = writeTitle(worksheet, currentRow, sheetData[0].length);\n  let dataRange = worksheet.getRangeByIndexes(currentRow, 0, sheetData.length, sheetData[0].length);\n  dataRange.setValues(sheetData);\n  formatSBC(dataRange, courses);\n}\nfunction makePrintable(courses : Course[]) : Course [] {\n  let newCourseList : Course[] = [];\n  for(let i = 0; i < courses.length; i++){\n    if(courses[i].numAssistants() > 0){\n      newCourseList.push(courses[i]);\n    }\n  }\n  return newCourseList;\n}\n\nfunction createSBC(workbook: ExcelScript.Workbook, worksheetName: string, color = \"00b0f0\", position = 5 ) : ExcelScript.Worksheet {\n  let worksheet = workbook.getWorksheet(worksheetName);\n  if(worksheet !== undefined) { \n    color = worksheet.getTabColor();\n    position = worksheet.getPosition();\n    worksheet.delete();\n  }\n  worksheet = workbook.addWorksheet(worksheetName);\n  formatSBCWorksheet(worksheet, color, position);\n  return worksheet; \n}\n\n// handles the overall formatting of an SBCSheet (column width, num columns, tab color, etc)\nfunction formatSBCWorksheet(worksheet : ExcelScript.Worksheet, color : string, position : number){\n  worksheet.setTabColor(color);\n  //worksheet.setPosition(position);\n\n\n}\n\n// writes error strings to the specified worksheet at the specified start row, returns the next empty row after errors are written\nfunction writeErrors(errors : string[], worksheet : ExcelScript.Worksheet, rowNum : number = 0, colSpan : number = 8) : number {\n  for (var error of errors){\n    let range = worksheet.getRangeByIndexes(rowNum, 0, 1, colSpan);\n    range.merge();\n      range.getFormat().getFont().setColor(\"FF0000\");\n      range.setValue(error);\n      rowNum++;\n  }\n  return rowNum;\n}\n\nfunction writeTitle(worksheet : ExcelScript.Worksheet, rowNum : number = 0, colSpan : number = 8) : number {\n  // get the range\n  let range = worksheet.getRangeByIndexes(rowNum, 0, 1, colSpan);\n  range.merge();\n\n  // set the appropriate look\n  let rangeFormat = range.getFormat();\n  rangeFormat.getFont().setBold(true);\n  rangeFormat.getFont().setSize(20);\n  rangeFormat.getFont().setColor(\"000000\");\n  rangeFormat.setHorizontalAlignment(ExcelScript.HorizontalAlignment.center);\n\n  // write the row\n  range.setValue(\"Learning Center schedule by Courses - [ENTER SEMESTER HERE]\");\n  rowNum+=3;\n\n  return rowNum;\n}\n\nfunction addBordersToRange(range : ExcelScript.Range){\n  let format = range.getFormat();\n  format.getRangeBorder(ExcelScript.BorderIndex.insideHorizontal).setStyle(ExcelScript.BorderLineStyle.continuous);\n  format.getRangeBorder(ExcelScript.BorderIndex.insideHorizontal).setColor(\"000000\");\n  format.getRangeBorder(ExcelScript.BorderIndex.insideHorizontal).setWeight(ExcelScript.BorderWeight.thin);\n  format.getRangeBorder(ExcelScript.BorderIndex.insideVertical).setStyle(ExcelScript.BorderLineStyle.continuous);\n  format.getRangeBorder(ExcelScript.BorderIndex.insideVertical).setColor(\"000000\");\n  format.getRangeBorder(ExcelScript.BorderIndex.insideVertical).setWeight(ExcelScript.BorderWeight.thin);\n  format.getRangeBorder(ExcelScript.BorderIndex.edgeBottom).setStyle(ExcelScript.BorderLineStyle.continuous);\n  format.getRangeBorder(ExcelScript.BorderIndex.edgeBottom).setColor(\"000000\");\n  format.getRangeBorder(ExcelScript.BorderIndex.edgeBottom).setWeight(ExcelScript.BorderWeight.thin);\n  format.getRangeBorder(ExcelScript.BorderIndex.edgeTop).setStyle(ExcelScript.BorderLineStyle.continuous);\n  format.getRangeBorder(ExcelScript.BorderIndex.edgeTop).setColor(\"000000\");\n  format.getRangeBorder(ExcelScript.BorderIndex.edgeTop).setWeight(ExcelScript.BorderWeight.thin);\n  format.getRangeBorder(ExcelScript.BorderIndex.edgeLeft).setStyle(ExcelScript.BorderLineStyle.continuous);\n  format.getRangeBorder(ExcelScript.BorderIndex.edgeLeft).setColor(\"000000\");\n  format.getRangeBorder(ExcelScript.BorderIndex.edgeLeft).setWeight(ExcelScript.BorderWeight.thin);\n  format.getRangeBorder(ExcelScript.BorderIndex.edgeRight).setStyle(ExcelScript.BorderLineStyle.continuous);\n  format.getRangeBorder(ExcelScript.BorderIndex.edgeRight).setColor(\"000000\");\n  format.getRangeBorder(ExcelScript.BorderIndex.edgeRight).setWeight(ExcelScript.BorderWeight.thin);\n}\n\nfunction formatSBC(range: ExcelScript.Range, courses: Course[], cFill = \"C9C9C9\", sFill = \"ffe699\"){\n  // the leftmost column needs special formatting \n  let format = range.getFormat();\n  let offset = 0;\n  let nameColFormat = range.getResizedRange(0,1 - range.getColumnCount()).getFormat();\n  addBordersToRange(range); // adds all borders\n\n  // set general format options\n  format.setWrapText(true);\n  format.setHorizontalAlignment(ExcelScript.HorizontalAlignment.center);\n  format.setVerticalAlignment(ExcelScript.VerticalAlignment.top);\n  format.setColumnWidth(100);\n\n  // set format options that only apply to name column\n  nameColFormat.setHorizontalAlignment(ExcelScript.HorizontalAlignment.left);\n  nameColFormat.setColumnWidth(175);\n\n  // fill cell color\n  for (let i = 0; i < courses.length; i++) {\n    format = range.getCell(i + offset,0).getEntireRow().getUsedRange().getFormat();\n    format.getFill().setColor(cFill);\n    format.getFont().setBold(true);\n    offset += courses[i].numAssistants();\n    if(courses[i].numAssistants() > 0){\n      offset+=1;\n      range.getCell(i + offset, 0).getEntireRow().getUsedRange().getFormat().getFill().setColor(sFill);\n    }\n  }\n}\n\nfunction checkForErrors(courses : string[][], schedule : string[][], laNamesCourse : string[], laNamesSchedule : string[],  courseSht : ExcelScript.Worksheet, schedSht : ExcelScript.Worksheet) : string[]{\n  // variables \n  let errors : string[] = [];\n\n  errors = errors.concat(checkNames(laNamesCourse, laNamesSchedule, schedSht));\n  errors = errors.concat(checkNames(laNamesSchedule, laNamesCourse, courseSht));\n  errors = errors.concat(checkShifts(schedule, schedSht));\n  errors = errors.concat(checkMarks(COURSE_NAME_START, COURSE_COL_START + 1, courses, courseSht));\n  return errors; \n}\n\n// checks to ensure a name from a list is in a given worksheet \nfunction checkNames(names1 : string [], names2 : string[], names2Wksht : ExcelScript.Worksheet) : string[]{\n  // variables\n  let errors : string[] = [];\n  let found : boolean;\n\n  // step through names of both arrays\n  for(let i = 0; i < names1.length; i++){\n    found = false;\n    if(normalize(names1[i])!= \"\"){\n      for( let j = 0; j < names2.length; j++){\n        //if a name is not in table, add an error message\n        if(normalize(names1[i]) === normalize(names2[j])){\n          found = true; \n        }\n      }\n      if(!found){\n        errors.push(\"Error: Name '\" + names1[i] + \"' not found in worksheet '\" + names2Wksht.getName() + \"'. Please resolve any naming descrepencies for a complete coverage list\")\n      }\n    }\n  }\n\n  return errors; \n}\n\n// ---------------- validates times in schedule sheet, returns information about errors -------------------\nfunction checkShifts(schedule : string[][], sheet : ExcelScript.Worksheet){\n  // variables\n  let errors : string[] = [];\n\n  // step through shifts in schedule sheet \n  for (let cellRow = SCHEDULE_NAME_START; cellRow < schedule.length; cellRow++) {\n    for (let cellCol = SCHEDULE_NAME_COL + 1; cellCol < schedule[0].length; cellCol++) {\n      // determine if the current sell contains a valid shift or is blank\n      if (!Shift.isShift(schedule[cellRow][cellCol]) && normalize(schedule[cellRow][cellCol]) != \"\") {\n        // indicate invalid data was found \n        errors.push(\"Error: The shifts contained in cell \" + sheet.getCell(cellRow, cellCol).getAddress() + \" are not parsable. Please ensure it is in H:MM-H:MM format\")\n      }\n    }\n  }\n\n  return errors;\n}\n\n// ---------------- validates transpose sheet and returns information about errors ------------------------\nfunction checkMarks(startRow : number, startCol : number, courses : string[][], sheet : ExcelScript.Worksheet) : string[] {\n  // variables \n  let errors : string[] = [];\n\n  // step through the mark area of the worksheet \n  for (let cellRow = startRow; cellRow < courses.length; cellRow++) {\n    for (let cellCol = startCol + 1; cellCol < courses[0].length; cellCol++) {\n      // deterine if the mark in the cell is valid \n      if (normalize(courses[cellRow][cellCol]) != \"\" && !normalize(courses[cellRow][cellCol]).toLowerCase().includes('x')) {\n        // push an error if the mark is not valid \n        errors.push(\"Error: The mark '\" + courses[cellRow][cellCol] + \"' located in cell \" + sheet.getCell(cellRow, cellCol).getAddress() + \" is not recognized. Please ensure an 'x' was used to indicate coverage.\");\n      }\n    }\n  }\n\n  // return all discovered errors \n  return errors;\n}","description":"","parameterInfo":"{\"originalParameterOrder\":[],\"parameterSchema\":{\"type\":\"object\",\"default\":{},\"x-ms-visibility\":\"internal\"},\"returnSchema\":{\"type\":\"object\",\"properties\":{}}}","apiInfo":"{\"variant\":\"synchronous\",\"variantVersion\":2}"}